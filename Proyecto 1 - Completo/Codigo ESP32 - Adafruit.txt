//Josué Castro
// Carnet 22082
// These constants won't change. They're used to give names to the pins used:
// === ESP32 (Arduino IDE) ===
// Lee líneas JSON por Serial2 desde el Nano y publica a Adafruit IO (MQTT).
// Ejemplo esperado desde el Nano: {"dist_cm": 123.4}
// Mantiene Serial (USB) para depuración y Serial2 (UART1) para el enlace con el Nano.

#include <WiFi.h>
#include "AdafruitIO_WiFi.h"

// ====== Mis credenciales ======
#define WIFI_SSID     "Dame la contraseña"        // tu red WiFi
#define WIFI_PASS     "nogracias"
#define AIO_USERNAME  "josfecar"
#define AIO_KEY        "aio_mbMO85BDjYSeVn92pV0uFU3VNukv"
// ==========================================
// Cliente Adafruit IO
AdafruitIO_WiFi io(AIO_USERNAME, AIO_KEY, WIFI_SSID, WIFI_PASS);
AdafruitIO_Feed *feedDist = io.feed("dist_cm");

// ==== UART con el Nano (Serial2) ====
#define ESP32_RX2 16   // GPIO16 (RX2)
#define ESP32_TX2 17   // GPIO17 (TX2)
#define LINK_BAUD 9600

// ==== Control de publicación (throttle) ====
const unsigned long MIN_PUBLISH_MS = 5000;  // no más de 1 dato cada 5 s (~12/min)
const float CHANGE_EPS = 0.5;               // publica si cambia >0.5 cm
float lastPublished = NAN;
unsigned long lastPubMs = 0;

// Buffer para línea recibida
String line;

// --- Función: extrae valor dist_cm de JSON ---
static bool extractDistCm(const String &s, float &out) {
  int k = s.indexOf("\"dist_cm\"");
  if (k < 0) return false;
  int colon = s.indexOf(':', k);
  if (colon < 0) return false;
  int endComma = s.indexOf(',', colon + 1);
  int endBrace = s.indexOf('}', colon + 1);
  int end = -1;
  if (endComma >= 0 && endBrace >= 0) end = min(endComma, endBrace);
  else if (endComma >= 0) end = endComma;
  else end = endBrace;
  if (end < 0) return false;
  String num = s.substring(colon + 1, end);
  num.trim();
  out = num.toFloat();
  return true;
}

void setup() {
  Serial.begin(115200);
  delay(300);
  Serial.println("\n[ESP32] Arrancando...");

  // Iniciar Serial2 para comunicar con el Nano
  Serial2.begin(LINK_BAUD, SERIAL_8N1, ESP32_RX2, ESP32_TX2);
  Serial.printf("[ESP32] Serial2 en %d bps (RX2=%d, TX2=%d)\n", LINK_BAUD, ESP32_RX2, ESP32_TX2);

  // Conectar a Adafruit IO
  Serial.println("[ESP32] Conectando a Adafruit IO...");
  io.connect();
  while (io.status() < AIO_CONNECTED) {
    Serial.printf("  estado IO: %s\n", io.statusText());
    io.run();
    delay(500);
  }
  Serial.printf("[ESP32] %s ✅\n", io.statusText()); // debería decir "Connected"
}

void loop() {
  io.run();  // mantener sesión con Adafruit IO

  // Leer línea completa desde Serial2
  while (Serial2.available()) {
    char c = (char)Serial2.read();
    if (c == '\r') continue;
    if (c == '\n') {
      if (line.length() > 0) {
        Serial.print("[ESP32] RX <- ");
        Serial.println(line);

        float dist;
        if (extractDistCm(line, dist) && !isnan(dist)) {
          unsigned long now = millis();
          bool timeOk = (now - lastPubMs) >= MIN_PUBLISH_MS;
          bool changeOk = isnan(lastPublished) || fabs(dist - lastPublished) > CHANGE_EPS;

          if (timeOk && changeOk) {
            feedDist->save(dist);
            lastPublished = dist;
            lastPubMs = now;
            Serial.printf("[ESP32] Publicado dist_cm = %.2f\n", dist);
          }
        } else {
          Serial.println("[ESP32] (No se encontró dist_cm o valor inválido)");
        }
        line = "";
      }
    } else {
      if (line.length() < 256) line += c;
      else line = "";
    }
  }

  delay(5); // evitar saturar CPU
}